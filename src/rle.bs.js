// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as List from "../node_modules/bs-platform/lib/es6/list.js";
import * as $$Array from "../node_modules/bs-platform/lib/es6/array.js";
import * as Bytes from "../node_modules/bs-platform/lib/es6/bytes.js";
import * as $$String from "../node_modules/bs-platform/lib/es6/string.js";
import * as Caml_bytes from "../node_modules/bs-platform/lib/es6/caml_bytes.js";
import * as Pervasives from "../node_modules/bs-platform/lib/es6/pervasives.js";
import * as Caml_format from "../node_modules/bs-platform/lib/es6/caml_format.js";
import * as Caml_string from "../node_modules/bs-platform/lib/es6/caml_string.js";
import * as Caml_builtin_exceptions from "../node_modules/bs-platform/lib/es6/caml_builtin_exceptions.js";

function explode(s) {
  var _i = s.length - 1 | 0;
  var _l = /* [] */0;
  while(true) {
    var l = _l;
    var i = _i;
    if (i < 0) {
      return l;
    } else {
      _l = /* :: */[
        Caml_string.get(s, i),
        l
      ];
      _i = i - 1 | 0;
      continue ;
    }
  };
}

function implode(l) {
  var res = Caml_bytes.caml_create_bytes(List.length(l));
  var imp = function (_i, _param) {
    while(true) {
      var param = _param;
      var i = _i;
      if (param) {
        res[i] = param[0];
        _param = param[1];
        _i = i + 1 | 0;
        continue ;
      } else {
        return res;
      }
    };
  };
  return Bytes.to_string(imp(0, l));
}

function parse_int(l) {
  var f = function (_acc, _l2) {
    while(true) {
      var l2 = _l2;
      var acc = _acc;
      if (l2) {
        var i = l2[0];
        if (i > 57 || i < 48) {
          return /* tuple */[
                  l2,
                  List.rev(acc)
                ];
        } else {
          _l2 = l2[1];
          _acc = /* :: */[
            i,
            acc
          ];
          continue ;
        }
      } else {
        return /* tuple */[
                l2,
                List.rev(acc)
              ];
      }
    };
  };
  var match = f(/* [] */0, l);
  return /* tuple */[
          match[0],
          Caml_format.caml_int_of_string(implode(match[1]))
        ];
}

function parse_header(_o, _l) {
  while(true) {
    var l = _l;
    var o = _o;
    var match = o.state;
    var exit = 0;
    if (l) {
      var switcher = l[0] - 32 | 0;
      if (switcher > 12 || switcher < 0) {
        if (switcher !== 29) {
          exit = 2;
        } else {
          _l = l[1];
          continue ;
        }
      } else if (switcher > 11 || switcher < 1) {
        _l = l[1];
        continue ;
      } else {
        exit = 2;
      }
    } else {
      exit = 2;
    }
    if (exit === 2) {
      switch (match) {
        case /* FindX */0 :
            if (l && l[0] === 120) {
              _l = l[1];
              _o = {
                state: /* ParseX */1,
                line: o.line,
                grid: o.grid,
                x: o.x,
                y: o.y
              };
              continue ;
            }
            break;
        case /* ParseX */1 :
            if (l && (l[0] - 48 >>> 0) <= 9) {
              var match$1 = parse_int(l);
              _l = match$1[0];
              _o = {
                state: /* FindY */2,
                line: o.line,
                grid: o.grid,
                x: match$1[1],
                y: o.y
              };
              continue ;
            }
            break;
        case /* FindY */2 :
            if (l && l[0] === 121) {
              _l = l[1];
              _o = {
                state: /* ParseY */3,
                line: o.line,
                grid: o.grid,
                x: o.x,
                y: o.y
              };
              continue ;
            }
            break;
        case /* ParseY */3 :
            if (l && (l[0] - 48 >>> 0) <= 9) {
              var match$2 = parse_int(l);
              _l = match$2[0];
              _o = {
                state: /* Reading */4,
                line: o.line,
                grid: o.grid,
                x: o.x,
                y: match$2[1]
              };
              continue ;
            }
            break;
        case /* Reading */4 :
            return o;
        case /* End */5 :
            break;
        
      }
    }
    if (l) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            $$String.make(1, l[0])
          ];
    }
    throw [
          Caml_builtin_exceptions.failure,
          "Incomplete header"
        ];
  };
}

function print_list(l) {
  List.iter((function (e) {
          return Pervasives.print_string($$String.make(1, e));
        }), l);
  Pervasives.print_string("\n");
  return /* () */0;
}

function print_cell_list(l) {
  List.iter((function (e) {
          return Pervasives.print_string(e === /* Dead */0 ? "x" : "o");
        }), l);
  Pervasives.print_string("\n");
  return /* () */0;
}

function parse_map(o, l) {
  var _n = 1;
  var _o = o;
  var _l = l;
  while(true) {
    var l$1 = _l;
    var o$1 = _o;
    var n = _n;
    if (l$1) {
      var c = l$1[0];
      if (c >= 48) {
        if (c !== 98) {
          if (c !== 111) {
            if (c >= 58) {
              throw [
                    Caml_builtin_exceptions.invalid_argument,
                    $$String.make(1, c)
                  ];
            }
            var match = parse_int(l$1);
            _l = match[0];
            _n = match[1];
            continue ;
          } else {
            var line = Pervasives.$at(List.init(n, (function (param) {
                        return /* Alive */1;
                      })), o$1.line);
            _l = l$1[1];
            _o = {
              state: o$1.state,
              line: line,
              grid: o$1.grid,
              x: o$1.x,
              y: o$1.y
            };
            _n = 1;
            continue ;
          }
        } else {
          var line$1 = Pervasives.$at(List.init(n, (function (param) {
                      return /* Dead */0;
                    })), o$1.line);
          _l = l$1[1];
          _o = {
            state: o$1.state,
            line: line$1,
            grid: o$1.grid,
            x: o$1.x,
            y: o$1.y
          };
          _n = 1;
          continue ;
        }
      } else if (c !== 33) {
        if (c !== 36) {
          throw [
                Caml_builtin_exceptions.invalid_argument,
                $$String.make(1, c)
              ];
        }
        var grid_000 = o$1.line;
        var grid_001 = o$1.grid;
        var grid = /* :: */[
          grid_000,
          grid_001
        ];
        _l = l$1[1];
        _o = {
          state: o$1.state,
          line: /* [] */0,
          grid: grid,
          x: o$1.x,
          y: o$1.y
        };
        _n = 1;
        continue ;
      } else {
        _l = l$1[1];
        _o = {
          state: /* End */5,
          line: o$1.line,
          grid: o$1.grid,
          x: o$1.x,
          y: o$1.y
        };
        _n = 1;
        continue ;
      }
    } else {
      return o$1;
    }
  };
}

function parse_line(o, s) {
  var l = explode(s);
  if (l === /* [] */0) {
    return o;
  } else {
    var c = List.hd(l);
    if (c === /* "#" */35) {
      return o;
    } else if (o.state === /* FindX */0) {
      return parse_header(o, l);
    } else {
      return parse_map(o, l);
    }
  }
}

function parse_lines(_o, _ss) {
  while(true) {
    var ss = _ss;
    var o = _o;
    if (ss) {
      _ss = ss[1];
      _o = parse_line(o, ss[0]);
      continue ;
    } else {
      return o;
    }
  };
}

function to_array(o) {
  o.x - List.length(o.grid) | 0;
  var grid = o.grid;
  var partial_arg = o.x;
  var grid2 = List.map((function (param) {
          var n = partial_arg;
          var l = param;
          var n2 = List.length(l);
          if (n2 < n) {
            return List.append(l, List.init(n - n2 | 0, (function (param) {
                              return /* Dead */0;
                            })));
          } else {
            return l;
          }
        }), grid);
  var grid3 = List.map(List.rev, grid2);
  return $$Array.of_list(List.rev_map($$Array.of_list, grid3));
}

function parse(text) {
  var ss = $$String.split_on_char(/* "\n" */10, text);
  return to_array(parse_lines({
                  state: /* FindX */0,
                  line: /* [] */0,
                  grid: /* [] */0,
                  x: 0,
                  y: 0
                }, ss));
}

function print_grid_line(_param) {
  while(true) {
    var param = _param;
    if (param) {
      if (param[0]) {
        Pervasives.print_string("o");
        _param = param[1];
        continue ;
      } else {
        Pervasives.print_string("x");
        _param = param[1];
        continue ;
      }
    } else {
      return /* () */0;
    }
  };
}

function print_grid(_param) {
  while(true) {
    var param = _param;
    if (param) {
      print_grid_line(param[0]);
      Pervasives.print_string("\n");
      _param = param[1];
      continue ;
    } else {
      return /* () */0;
    }
  };
}

export {
  explode ,
  implode ,
  parse_int ,
  parse_header ,
  print_list ,
  print_cell_list ,
  parse_map ,
  parse_line ,
  parse_lines ,
  to_array ,
  parse ,
  print_grid_line ,
  print_grid ,
  
}
/* No side effect */
